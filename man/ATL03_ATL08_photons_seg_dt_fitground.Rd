% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ATL03_ATL08_photons_seg_dt_fitground.R
\name{ATL03_ATL08_photons_seg_dt_fitground}
\alias{ATL03_ATL08_photons_seg_dt_fitground}
\title{Fit and estimate ground elevation for photons or arbitrary distances
from the track beginning}
\usage{
ATL03_ATL08_photons_seg_dt_fitground(
  atl03_atl08_seg_dt,
  smoothing_window = NA,
  smoothing_func = median,
  interpolation_func = NA,
  xout_parameter_name = "xout",
  ...
)
}
\arguments{
\item{atl03_atl08_seg_dt}{An S4 object of class \code{\linkS4class{icesat2.atl03_atl08_seg_dt}} containing ATL03 and ATL08 data
(output of \code{\link[=ATL03_ATL08_photons_attributes_dt_join]{ATL03_ATL08_photons_attributes_dt_join()}} function).}

\item{smoothing_window}{numeric. The smoothing window size in meters for smoothing the photon cloud.
Default is NA, see details for more information.}

\item{smoothing_func}{function. The smoothing function to be applied on the smoothing window.}

\item{interpolation_func}{function. The interpolation function to estimate the ground elevation.}

\item{xout_parameter_name}{character. Optional, can be used to inform the parameter name that the
interpolation_func uses for passing the prediction vector and already use the photons for prediction.
Default NA will use the ...}

\item{...}{Optional parameters to pass to the interpolation_func, see details for more information.}
}
\description{
Function to estimate ground elevation using smoothing and
interpolation functions
}
\details{
The function for calculating the ground will first pass a smoothing
window with \code{smoothing_window} size,
applying the \code{smoothing_func} to aggregate the ground photons.

Then it will use an interpolation function between those
aggregated photons to calculate a smooth surface.

The \code{smoothing_func} signature will depend on the function used.
It is assumed that the first two arguments are vectors of \code{x} (independent
variable) and \code{y} (the prediction to be interpolated). The remaining
arguments are passed through \code{...}.

The interpolation functions need a third parameter which is the
\code{x} vector to be interpolated. Functions from \code{stats} base package
\code{stats::approx()} and \code{stats::spline()} name this argument as \code{xout},
so you can use:

\if{html}{\out{<div class="sourceCode">}}\preformatted{ATL03_ATL08_photons_fitground_seg_dt(
  dt,
  interpolation_func = approx,
  xout = 1:30
)
}\if{html}{\out{</div>}}

For example, to interpolate the values for the 1:30 vector. However, other
functions may name the parameter differently, such as \code{signal::pchip()},
which calls the parameter \code{xi} instead of \code{xout}.
The \code{pchip} algorithm (as implemented in the \strong{signal} package)
is the one used by the ATL08 ATBD.

The \code{smoothing_window} can be left NA, which will use the ATBD algoritm
for calculating the window size:

\eqn{Sspan = ceil[5 + 46 * (1 - e^{-a * length})]}, where \emph{length}
is the number of photons within segment.

\deqn{a \approx 21x10^{-6}}

\deqn{window_size = \frac{2}{3} Sspan}

This is not the same algorithm as used in ATL08
but is an adapted version that uses the ATL08
pre-classification
}
