% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ATL08_seg_attributes_h5_gridStat.R
\name{ATL08_seg_attributes_h5_gridStat}
\alias{ATL08_seg_attributes_h5_gridStat}
\title{Rasterize ATL08 canopy attributes from h5 files at large scale}
\usage{
ATL08_seg_attributes_h5_gridStat(
  atl08_dir,
  metrics = c("h_canopy", "canopy_rh_conf", "h_median_canopy_abs", "h_min_canopy",
    "h_mean_canopy_abs", "h_median_canopy", "h_canopy_abs", "toc_roughness",
    "h_min_canopy_abs", "h_dif_canopy", "h_canopy_quad", "h_canopy_20m", "n_ca_photons",
    "photon_rate_can", "centroid_height", "canopy_h_metrics_abs", "h_mean_canopy",
    "subset_can_flag", "canopy_h_metrics", "n_toc_photons", "h_max_canopy_abs",
    "h_canopy_uncertainty", "canopy_openness", "h_max_canopy", "segment_cover"),
  beam = c("gt1l", "gt1r", "gt2l", "gt2r", "gt3l", "gt3r"),
  out_root,
  clip_obj,
  res,
  creation_options = def_co,
  agg_function = default_agg_function,
  agg_join = default_agg_join,
  finalizer = default_finalizer
)
}
\arguments{
\item{atl08_dir}{CharacterVector. The directory paths where the ATL08 H5 files are stored;}

\item{metrics}{CharacterVector. A vector of canopy attributes available from ATL08 product (e.g. "h_canopy")}

\item{beam}{Character vector indicating beams to process (e.g. "gt1l", "gt1r", "gt2l", "gt2r", "gt3l", "gt3r")}

\item{out_root}{Character. The root name for the raster output files, the pattern is
\{out_root\}\emph{\{metric\}}\{count/m1/m2\}.tif. This should include the full path for the file.}

\item{clip_obj}{Bounding extent or spatial object used to define the clipping area.
Supported inputs:
\itemize{
\item Numeric vector of length 4: \code{c(xmin, ymin, xmax, ymax)} in decimal degrees.
\item \code{terra::SpatExtent}.
\item \code{terra::SpatVector} (polygon/multipolygon).
\item \code{sf} / \code{sfc} object.
}
When a polygon object is provided (\code{SpatVector}, \code{sf}, \code{sfc}),
ATL08 segments are clipped using \code{ATL08_seg_attributes_dt_clipBox()}.
Otherwise (numeric bbox or \code{SpatExtent}), clipping is done with
\code{ATL08_seg_attributes_dt_clipBox()}.}

\item{res}{NumericVector. Resolution lon lat for the output raster in coordinates decimal degrees}

\item{creation_options}{CharacterVector. The GDAL creation options for the tif file. Default c("COMPRESS=PACKBITS", "BIGTIFF=IF_SAFER", "TILED=YES", "BLOCKXSIZE=512", "BLOCKYSIZE=512") will create BIGTIFF if needed, with DEFLATE compression and tiled by 512x512 pixels.}

\item{agg_function}{Formula function-like. An aggregate function which should return a data.table with the aggregate statistics}

\item{agg_join}{Function. A function to merge two different agg objects.}

\item{finalizer}{List<name, formula>. A list with the final raster names and the formula which uses the base statistics.}
}
\value{
Nothing. It outputs multiple raster tif files to the out_root specified path.
}
\description{
This function will read multiple ATL08 H5 files and create a stack of raster layers: count, and 1st, 2nd, 3rd and 4th moments (count, m1, m2, m3 and m4) for each metric selected, from which we can calculate statistics such as Mean, SD, Skewness and Kurtosis.
}
\details{
This function will create five different aggregate statistics
(n, mean, variance, min, max).
One can calculate mean and standard deviation with the following
formulas according to Terriberry (2007).

The \code{agg_function} is a formula which return a data.table with the
aggregate function to perform over the data.
The default is:

\if{html}{\out{<div class="sourceCode">}}\preformatted{~data.table(
    n = length(x),
    mean = mean(x,na.rm = TRUE),
    var = var(x) * (length(x) - 1),
    min = min(x, na.rm=T),
    max = max(x, na.rm=T)
  )
}\if{html}{\out{</div>}}

The \code{agg_join} is a function to merge two data.table aggregates
from the \code{agg_function}. Since the h5 files will be aggregated
one by one, the statistics from the different h5 files should
have a function to merge them. The default function is:

\if{html}{\out{<div class="sourceCode">}}\preformatted{function(x1, x2) \{
    combined = data.table()
    x1$n[is.na(x1$n)] = 0
    x1$mean[is.na(x1$mean)] = 0
    x1$variance[is.na(x1$variance)] = 0
    x1$max[is.na(x1$max)] = -Inf
    x1$min[is.na(x1$min)] = Inf

    combined$n = x1$n + x2$n

    delta = x2$mean - x1$mean
    delta2 = delta * delta

    combined$mean = (x1$n * x1$mean + x2$n * x2$mean) / combined$n
    combined$variance = x1$variance + x2$variance +
      delta2 * x1$n * x2$n / combined$n

    combined$min = pmin(x1$min, x2$min, na.rm=F)
    combined$max = pmax(x1$max, x2$max, na.rm=F)
    return(combined)
\}
}\if{html}{\out{</div>}}

The \code{finalizer} is a list of formulas to generate the final
rasters based on the intermediate statistics from the previous
functions. The default \code{finalizer} will calculate the \code{sd},
\code{skewness} and \code{kurtosis} based on the \code{variance}, \code{M3}, \code{M4} and \code{n}
values. It is defined as:

\if{html}{\out{<div class="sourceCode">}}\preformatted{list(
  sd = ~sqrt(variance/(n - 1)),
)
}\if{html}{\out{</div>}}
}
\examples{
\dontrun{
library(data.table)

# Specifying the path to ATL08 file
atl08_path <- system.file("extdata",
  "atl08_clip.h5",
  package = "ICESat2VegR"
)

# Reading ATL08 data (h5 file)
atl08_h5 <- ATL08_read(atl08_path = atl08_path)

# Bounding rectangle as numeric bbox: c(xmin, ymin, xmax, ymax)
clip_obj <- c(
  xmin = -106.5708541870117188,
  ymin =  41.5314979553222656,
  xmax = -106.5699081420898438,
  ymax =  41.5386848449707031
)

res <- 100 # meters
lat_to_met_factor <- 1 / 110540
lon_to_met_factor <- 1 / 111320
xres <- lon_to_met_factor * res
yres <- lat_to_met_factor * res

agg_function <- ~ data.table(
  min = min(x),
  max = max(x),
  sum = sum(x),
  n = length(x)
)

agg_join <- function(agg1, agg2) {
  agg1[is.na(agg1)] <- 0
  data.table(
    min = pmin(agg1$min, agg2$min),
    max = pmax(agg1$max, agg2$max),
    sum = agg1$sum + agg2$sum,
    n = agg1$n + agg2$n
  )
}

finalizer <- list(
  mean  = "sum/n",
  range = "max-min"
)

outdir <- tempdir()

# ATL08_seg_attributes_h5_gridStat(
#   atl08_dir        = dirname(atl08_path),
#   metrics          = c("h_canopy"),
#   out_root         = outdir,
#   beam             = c("gt1l","gt1r","gt2l","gt2r","gt3l","gt3r"),
#   clip_obj         = clip_obj,
#   res              = c(xres, -yres),
#   creation_options = c(
#     "COMPRESS=DEFLATE",
#     "BIGTIFF=IF_SAFER",
#     "TILED=YES",
#     "BLOCKXSIZE=512",
#     "BLOCKYSIZE=512"
#   ),
#   agg_function     = agg_function,
#   agg_join         = agg_join,
#   finalizer        = finalizer
# )

gc()
file.remove(list.files(outdir, "*.tif"))
close(atl08_h5)
}

}
\references{
Terriberry, Timothy B. (2007), Computing Higher-Order Moments Online, archived from the original on 23 April 2014, retrieved 5 May 2008
}
